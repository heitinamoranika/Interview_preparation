[TOC]

# 2019年校招编程题

## 牛牛找工作

题目描述
为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。
输入描述:
每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。
输出描述:
对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。
示例1
输入
复制
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000
输出
复制
100 
1000 
1001



```python
import sys
import bisect
task = {}
lines = sys.stdin.readlines()
n, m = map(int, lines[0].strip().split())
for line in lines[1:-1]:
    if not line.strip().split():
        continue
    a, b = map(int, line.strip().split())
    task[a] = max(task.get(a, 0), b)
arr = sorted(task.keys())
for i in range(1, len(arr)):
    if task[arr[i]] < task[arr[i -1]]:
        task[arr[i]] = task[arr[i -1]]
skills = map(int, lines[-1].strip().split())
for skill in skills:
    if skill in task:
        print(task[skill])
    else:
        ind = bisect.bisect(arr, skill)
        if ind == 0:
            print(0)
        else:
            print(task[arr[ind -1]])
```

## 被三整除

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

输入描述:
输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。
输出描述:
输出一个整数, 表示区间内能被3整除的数字个数。
示例1
输入
复制
2 5
输出
复制
3
说明
12, 123, 1234, 12345...
其中12, 123, 12345能被3整除。

```python
l,r = map(int,input().split())
d = r-l
if l%3==0:
    print(((d-1)//3)*2+1+(d-1)%3)
elif l%3==1:
    l-=1
    d = r-l
    print(((d-1)//3)*2+(d-1)%3)   
else:
    l-=2
    d = r-l
    print(((d-1)//3)*2+(d-1)%3)
```

## 万万没想到之聪明的编辑

题目描述
我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：

1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello
2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello
3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！
……
万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……

请听题：请实现大锤的自动校对程序
输入描述:
第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。

后面跟随N行，每行为一个待校验的字符串。
输出描述:
N行，每行包括一个被修复后的字符串。
示例1
输入
复制
2
helloo
wooooooow
输出
复制
hello
woow

```
n = int(input())
while n>0:
    s = input()
    res = []
    for e in s:
        if len(res)<2:
            res.append(e)
            continue
        if len(res)>=2:
            if e ==res[-1] and e==res[-2]:
                continue
        if len(res)>=3:
            if e==res[-1] and res[-2]==res[-3]:
                continue
        res.append(e)
    print("".join(res))
    n-=1
```

## 丰收

题目描述
又到了丰收的季节，恰逢小易去牛牛的果园里游玩。
牛牛常说他对整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。
在果园里有N堆苹果，每堆苹果的数量为ai，小易希望知道从左往右数第x个苹果是属于哪一堆的。
牛牛觉得这个问题太简单，所以希望你来替他回答。
输入描述:
第一行一个数n(1 <= n <= 105)。
第二行n个数ai(1 <= ai <= 1000)，表示从左往右数第i堆有多少苹果
第三行一个数m(1 <= m <= 105)，表示有m次询问。
第四行m个数qi，表示小易希望知道第qi个苹果属于哪一堆。
输出描述:
m行，第i行输出第qi个苹果属于哪一堆。
示例1
输入
复制
5
2 7 3 4 9
3
1 25 11
输出
复制
1
5
3

```python
n = int(input())
A = list(map(int,input().split()))
m = int(input())
Q = list(map(int,input().split()))
 
from itertools import accumulate
import bisect
 
 
Asum = list(accumulate(A))
Asum
 
for q in Q:
    idx = bisect.bisect_left(Asum, q)
    print(idx + 1)
```

## 瞌睡

题目描述
小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。
输入描述:
第一行 n, k (1 <= n, k <= 105) ，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。
第二行 n 个数，a1, a2, ... , an(1 <= ai <= 104) 表示小易对每分钟知识点的感兴趣评分。
第三行 n 个数，t1, t2, ... , tn 表示每分钟小易是否清醒, 1表示清醒。
输出描述:
小易这堂课听到的知识点的最大兴趣值。
示例1
输入
复制
6 3
1 3 5 2 5 4
1 1 0 1 0 0
输出
复制
16

```
n,k =list(map(int, input().split()))
values =list(map(int, input().split()))
awakes =list(map(int, input().split()))
#n,k = [6,3]
#values = [1, 3, 5, 2, 5, 4]
#awakes = [1, 1, 0, 1, 0, 0]
    
base_score =0
for i in range(n):
    if awakes[i]:
        base_score += values[i]
        values[i] =0
            
max_boost_score =0
for i in range(n):
    if not awakes[i]:
        boost_score =sum(values[i:min(i+k,n)])
        max_boost_score =max(boost_score,max_boost_score)
        # 加了下面的break语句，才使这个代码时间上终于达标
        # 扫描到距结尾不足k距离范围内的第一个睡着状态即可，后面的肯定不如这个的提升值大，没必要再跑，可提前结束
        if i > n-k+1:
            break
            
score =base_score +max_boost_score
print(score)

```

## 数对

题目描述
牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。

但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。
牛牛希望你能帮他计算一共有多少个可能的数对。

输入描述:
输入包括两个正整数n,k(1 <= n <= 10^5, 0 <= k <= n - 1)。
输出描述:
对于每个测试用例, 输出一个正整数表示可能的数对数量。
示例1
输入
复制
5 2
输出
复制
7
说明
满足条件的数对有(2,3),(2,4),(2,5),(3,4),(3,5),(4,5),(5,3)

```
n, k = map(int, input().split())
count = 0
if k == 0:
        count = n * n
else:
    for y in range(k+1, n+1):
            count += (n // y) * (y - k)
            if n % y >= k:
                count += (n % y - k + 1)
print(count)
```

## 表达式求值

今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：
1
2
3
4
1+2*3=7
1*(2+3)=5
1*2*3=6
(1+2)*3=9
现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加"+"， "*"， "("， ")"符号，能够获得的最大值。

```
A = list(map(int,input().split()))
 
A.sort()
 
if A[0]==1:
    print((A[0]+A[1])*A[2])
else:
    print(A[0]*A[1]*A[2])
```

## 安置路灯

题目描述
小Q正在给一条长度为n的道路设计路灯安置方案。

为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要照亮的障碍物格子用'X'表示。

小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。

小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需要多少盏路灯。

输入描述:
输入的第一行包含一个正整数t(1 <= t <= 1000), 表示测试用例数
接下来每两行一个测试数据, 第一行一个正整数n(1 <= n <= 1000),表示道路的长度。
第二行一个字符串s表示道路的构造,只包含'.'和'X'。
输出描述:
对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。
示例1
输入
复制
2
3
.X.
11
...XX....XX
输出
复制
1
3

```
def GetLaternNum(street):
    street_len=len(street)
   
    laternNum=0
    i=0
    while(i<street_len):
        if(street[i]=='.'):
            laternNum+=1;
            i+=3;
        else:
            i+=1;
   
    return laternNum
   
TestNum=int(input())
   
for i in range(TestNum):
    streen_len=int(input())
    street=input()
           
    print(GetLaternNum(street))
```

# SQL 必知必会

## Select

```sql
SELECT prod_name FROM Products;

SELECT prod_id, prod_name, prod_price FROM Products;

SELECT * FROM Products;#所有列

SELECT DISTINCT vend_id FROM Products; #不同值

SELECT TOP 5 prod_name FROM Products;

SELECT prod_name FROM Products LIMIT 2 OFFSET 5; #第二行开始五行

SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01');
```



## Order

```
SELECT prod_name FROM Products ORDER BY prod_name;

SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name;

SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC;#倒序

SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC, prod_name;
```



## Where

```
SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49;

#在同时使用 ORDER BY 和 WHERE 子句时，应该让 ORDER BY 位于 WHERE 之后， 否则将会产生错误

SELECT vend_id, prod_name FROM Products WHERE vend_id <> 'DLL01'; #不匹配

SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; #范围搜索

SELECT prod_id, prod_price, prod_name FROM Products WHERE vend_id = 'DLL01' AND prod_price <= 4;

SELECT prod_name, prod_price FROM Products WHERE vend_id = 'DLL01' OR vend_id = ‘BRS01’;

SELECT prod_name, prod_price FROM Products WHERE vend_id IN ( 'DLL01', 'BRS01' ) ORDER BY prod_name;

SELECT prod_name FROM Products WHERE NOT vend_id = 'DLL01' ORDER BY prod_name; #否定其后条件的关键字。

SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE 'Fish%'; #所有以词 Fish 起头的产品

SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '%bean bag%'; #搜索模式'%bean bag%'表示匹配任何位置上包含文本 bean bag 的值， 不论它之前或之后出现什么字符。

SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '__ inch teddy bear'; #另一个有用的通配符是下划线（_）。下划线的用途与%一样，但它只匹配 单个字符，而不是多个字符。



```



## 拼接和其他聚集函数

```
SELECT vend_name + ' (' + vend_country + ')' FROM Vendors ORDER BY vend_name;

SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM OrderItems WHERE order_num = 20008;

SELECT vend_name, UPPER(vend_name) AS vend_name_upcase FROM Vendors ORDER BY vend_name; #全大写

SELECT AVG(prod_price) AS avg_price FROM Products;

SELECT AVG(prod_price) AS avg_price FROM Products WHERE vend_id = 'DLL01';

SELECT COUNT(*) AS num_cust FROM Customers;

SELECT MAX(prod_price) AS max_price FROM Products;

SELECT SUM(quantity) AS items_ordered FROM OrderItems WHERE order_num = 20005;

SELECT SUM(item_price*quantity) AS total_price FROM OrderItems WHERE order_num = 20005;

SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products WHERE vend_id = 'DLL01';

SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg FROM Products;
```



## 分组 GROUP BY; 过滤分组HAVING



，WHERE 过滤行，而 HAVING 过滤分组。

```
SELECT vend_id, COUNT(*) AS num_prods FROM Products GROUP BY vend_id;

SELECT cust_id, COUNT(*) AS orders FROM Orders GROUP BY cust_id HAVING COUNT(*) >= 2;

SELECT vend_id, COUNT(*) AS num_prods FROM Products WHERE prod_price >= 4 GROUP BY vend_id HAVING COUNT(*) >= 2; #WHERE 子句过滤所有 prod_price 至少为 4 的行，然后按 vend_id 分组数据，HAVING 子句过滤计数为 2 或 2 以上的分组。

SELECT order_num, COUNT(*) AS items FROM OrderItems GROUP BY order_num HAVING COUNT(*) >= 3;#。下面的 SELECT 语句类似于前面那些例子。它检索包含三个或更多物品的订单号和订购物品的数目：

#要按订购物品的数目排序输出，需要添加 ORDER BY 子句，如下所示：
SELECT order_num, COUNT(*) AS items FROM OrderItems GROUP BY order_num HAVING COUNT(*) >= 3 ORDER BY items, order_num;


```



## 链接

```
SELECT vend_name, prod_name, prod_price 
FROM Vendors INNER 
JOIN Products 
ON Vendors.vend_id = Products.vend_id;

SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01';

SELECT Customers.cust_id, Orders.order_num FROM Customers LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id;
```



## 组合查询

```
SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL','IN','MI') UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = 'Fun4All';

#union all 不取消重复行

SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL','IN','MI') UNION ALL SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = 'Fun4All';
```



## Insert

```
INSERT INTO Customers VALUES('1000000006','Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL);

INSERT INTO Customers(cust_id,cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000006','Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL);

INSERT INTO Customers(cust_id,cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)
SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country FROM CustNew;

SELECT * INTO CustCopy FROM Customers; #复制表


```

## Update & Delete

```
UPDATE Customers SET cust_email = 'kim@thetoystore.com' WHERE cust_id = '1000000005';

UPDATE Customers SET cust_contact = 'Sam Roberts', cust_email = 'sam@toyland.com' WHERE cust_id = '1000000006';

UPDATE Customers SET cust_email = NULL WHERE cust_id = '1000000005';

DELETE FROM Customers WHERE cust_id = '1000000006'; #如果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。
```

## Create & Alter

```
CREATE TABLE Products ( 
prod_id CHAR(10)  NOT NULL, 
vend_id CHAR(10)  NOT NULL, 
prod_name CHAR(254)  NOT NULL, 
prod_price DECIMAL(8,2)  NOT NULL , 
prod_desc VARCHAR(1000) NULL, 
quantity INTEGER NOT NULL DEFAULT 1,
);
#如果不指定 NOT NULL，就认为指定的是 NULL。

ALTER TABLE Vendors ADD vend_phone CHAR(20); 增加一列

DROP TABLE CustCopy; 删除表

```



1）DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。

   TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2）表和索引所占空间。

   当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，

   DELETE操作不会减少表或索引所占用的空间。

   drop语句将表所占用的空间全释放掉。

（3）一般而言，drop > truncate > delete

（4）应用范围。

    TRUNCATE 只能对TABLE；         DELETE可以是table和view

（5）TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）。

（6）truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7）delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8）truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9）在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为: 
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

一、delete

1、delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。

2、delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。

3、delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。

二、truncate

1、truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。

2、truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。

3、对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。

4、truncatetable不能用于参与了索引视图的表。

三、drop

1、drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。

2、drop语句删除表结构及所有数据，并将表所占用的空间全部释放。

3、drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。

 

总结：

1、在速度上，一般来说，drop> truncate > delete。

2、在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。

3、如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；

   如果想删除表，当然用drop； 

   如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；

   如果和事务有关，或者想触发trigger，还是用delete；

   如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。

每天进步一步步，坚持坚持坚持











